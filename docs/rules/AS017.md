# AS017: Scripts Have Error Handling

## Source

**Official Documentation**: [Code and Scripts Checklist - Agent Skills Best Practices](https://platform.claude.com/docs/en/agents-and-tools/agent-skills/best-practices#evaluation-and-iteration)

## Rule Description

Scripts must have explicit error handling. Don't punt error detection to Claude.

## Requirements

For all scripts in the skill:
1. Handle expected error conditions
2. Provide clear error messages
3. Exit with appropriate codes
4. Validate inputs before processing

## Rationale

**Claude cannot recover from cryptic errors**. When scripts fail without error handling:

1. **Cryptic failures**: Stack traces and error codes Claude can't interpret
2. **Wasted tokens**: Claude tries to debug system-level errors
3. **Poor UX**: Users see technical errors, not helpful messages
4. **Silent failures**: Missing checks cause incorrect results

**With proper error handling**:
- Clear actionable error messages
- Fast failure with useful guidance
- Predictable behavior
- Better debugging path

## Good Examples

**Python with error handling**:

```python
#!/usr/bin/env python3
import sys

def process_pdf(filepath):
    # Validate input
    if not filepath:
        print("ERROR: No file path provided", file=sys.stderr)
        print("Usage: process_pdf.py <path/to/file.pdf>", file=sys.stderr)
        sys.exit(1)

    # Check file exists
    if not os.path.exists(filepath):
        print(f"ERROR: File not found: {filepath}", file=sys.stderr)
        sys.exit(1)

    # Check file extension
    if not filepath.endswith('.pdf'):
        print(f"ERROR: Not a PDF file: {filepath}", file=sys.stderr)
        print("Expected file ending with .pdf", file=sys.stderr)
        sys.exit(1)

    # Check dependencies
    try:
        import pdfplumber
    except ImportError:
        print("ERROR: pdfplumber not installed", file=sys.stderr)
        print("Install with: pip install pdfplumber", file=sys.stderr)
        sys.exit(1)

    # Process with error handling
    try:
        with pdfplumber.open(filepath) as pdf:
            return pdf.pages[0].extract_text()
    except Exception as e:
        print(f"ERROR: Failed to process PDF: {e}", file=sys.stderr)
        sys.exit(1)
```

**Bash with error handling**:

```bash
#!/bin/bash
set -euo pipefail  # Exit on error, undefined vars, pipe failures

# Validate arguments
if [ $# -eq 0 ]; then
    echo "ERROR: No input file provided" >&2
    echo "Usage: $0 <input.csv>" >&2
    exit 1
fi

INPUT_FILE="$1"

# Check file exists
if [ ! -f "$INPUT_FILE" ]; then
    echo "ERROR: File not found: $INPUT_FILE" >&2
    exit 1
fi

# Check dependencies
if ! command -v jq &> /dev/null; then
    echo "ERROR: jq not installed" >&2
    echo "Install with: brew install jq (macOS) or apt-get install jq (Linux)" >&2
    exit 1
fi

# Process with error handling
if ! jq '.' "$INPUT_FILE" > /dev/null 2>&1; then
    echo "ERROR: Invalid JSON in $INPUT_FILE" >&2
    exit 1
fi

# Main processing
jq '.data[] | .name' "$INPUT_FILE" || {
    echo "ERROR: Failed to extract names from $INPUT_FILE" >&2
    exit 1
}
```

**Node.js with error handling**:

```javascript
#!/usr/bin/env node
const fs = require('fs');

function processFile(filepath) {
    // Validate input
    if (!filepath) {
        console.error('ERROR: No file path provided');
        console.error('Usage: node process.js <path/to/file>');
        process.exit(1);
    }

    // Check file exists
    if (!fs.existsSync(filepath)) {
        console.error(`ERROR: File not found: ${filepath}`);
        process.exit(1);
    }

    // Read with error handling
    let content;
    try {
        content = fs.readFileSync(filepath, 'utf8');
    } catch (err) {
        console.error(`ERROR: Failed to read file: ${err.message}`);
        process.exit(1);
    }

    // Parse with error handling
    try {
        return JSON.parse(content);
    } catch (err) {
        console.error(`ERROR: Invalid JSON: ${err.message}`);
        process.exit(1);
    }
}
```

## Bad Examples

**No error handling**:

```python
#!/usr/bin/env python3
import pdfplumber

# No argument validation
filepath = sys.argv[1]

# No file existence check
# No dependency check
# No error handling
with pdfplumber.open(filepath) as pdf:
    print(pdf.pages[0].extract_text())
```

**Generic error handling**:

```python
try:
    # Lots of operations
    ...
except:
    print("Something went wrong")  # Not helpful!
```

**Letting errors propagate**:

```bash
#!/bin/bash
# No set -e, errors ignored
jq '.' input.json  # Fails silently if jq missing
cat output.txt  # Fails silently if file missing
```

## Detection

This rule scans scripts for error handling patterns:

**For Python** (`.py` files):
- Looks for: `try/except`, `if not`, `sys.exit()`, `raise`
- Checks imports: `sys`, `argparse` (for input validation)
- Flags scripts without basic error handling

**For Bash** (`.sh` files):
- Looks for: `set -e`, `if [ ! -f ]`, `exit 1`, `|| { ... }`
- Checks for: `command -v` (dependency checks)
- Flags scripts without error handling

**For Node.js** (`.js` files):
- Looks for: `try/catch`, `if (!...)`, `process.exit()`
- Checks for: `fs.existsSync` (file validation)
- Flags scripts without error handling

## Severity

- **Default**: Warning
- **Strict mode**: Error

## Essential Error Handling Patterns

**1. Input validation**:
```python
if not filepath:
    print("ERROR: Missing required argument", file=sys.stderr)
    sys.exit(1)
```

**2. File existence**:
```python
if not os.path.exists(filepath):
    print(f"ERROR: File not found: {filepath}", file=sys.stderr)
    sys.exit(1)
```

**3. Dependency checks**:
```python
try:
    import required_module
except ImportError:
    print("ERROR: required_module not installed", file=sys.stderr)
    sys.exit(1)
```

**4. Operation failures**:
```python
try:
    result = risky_operation()
except SpecificError as e:
    print(f"ERROR: Operation failed: {e}", file=sys.stderr)
    sys.exit(1)
```

## Related Rules

- AS013: Document required packages (dependency documentation complements dependency checking)
- AS018: No undocumented magic constants (clear error thresholds)
